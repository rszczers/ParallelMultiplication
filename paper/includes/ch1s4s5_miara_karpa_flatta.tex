Przyspieszenia uzyskiwane ze wzorów \eqref{eq:amdahl} i \eqref{eq:gustafson_barsis} nie uwzględniają złożoności \(T_{p}^{O}(n)\) związanej z prowadzeniem obliczeń i dlatego ich wartości są większe niż uzyskiwane doświadczalnie.

Zgodnie z wyrażeniem \ref{eq:supSpn} czas wykonywania algorytmu równoległego jest równy:
\begin{align}\label{eq:karp_flatt_1}
T_{p}(n)=T_{1}^{s}(n)+T_{p}^{0}(n) + \frac{T_{1}^{r}(n)}{p}
\end{align}

Jeśli przez \(f\) oznaczymy częśc operacji algorytmu, których nie można zrównoleglić (część \emph{inherentnie sekwencyjną}) oraz złożoność dodatkową wynikającą z organizacji obliczeń, to mamy:

\begin{align}
f=\frac{T_{1}^{s}(n)+T_{p}^{O}(n)}{T_{1}(n)}\label{eq:karp_flatt2}
\end{align}

Z \eqref{eq:karp_flatt_1} i \eqref{eq:karp_flatt2}:

\begin{align}
T_{p}(n)=T_{1}^{s}(n)+T_{p}^{O}(n)+\frac{T_{1}^{r}(n)}{p} = fT_{1}(n)+\frac{(1-f)T_{1}(n)}{p}
\end{align}

Dzieląć obie strony równania przez \(T_{1}(n)\) otrzymujemy

\begin{align}\label{eq:karp_flatt_3}
f=\frac{\frac{1}{S_{p}(n)}-\frac{1}{p}}{1-\frac{1}{p}}
\end{align}

Wyrażenie \eqref{eq:karp_flatt_3} nazywamy \textbf{miarą Karpa-Flatta}.

\begin{definicja}[Miara Karpa-Flatta]
Dla danego algorytmu równoległego \(R\) rozwiązującego problem \(P\) o rozmiarze \(n\) przy pomocy \(p>1\) procesorów, doświadczalnie wyznaczona część sekwencyjna obliczeń \(f\) wyraża się przez
\begin{align}
f = \frac{1/S_{p}(n) - 1/p}{1 - 1/p}
\end{align}
\end{definicja}

\begin{przyklad}\label{ex:karp1}
Powiedzmy, że testując algorytm równoległy na \(1, 2, \dots, 8\) procesorach otrzymaliśmy pewne przyspieszenia w zależności od ilości procesów i z wyrażenia \ref{eq:karp_flatt_3} obliczyliśmy eksperymentalnie wyznaczoną część sekwencyjną f. Dane zebrane są w tablicy \ref{tab:karp_flat1}.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\(p\) & \(2\) & \(3\) & \(4\) & \(5\) & \(6\) & \(7\) & \(8\) \\
\hline
\(S_p(n)\) & \(1,82\) & \(2,50\) & \(3,08\) & \(3,57\) & \(4,00\) & \(4,38\) & \(4,71\) \\
\hline
\(f\) & \(0,10\) & \(0,10\) & \(0,10\) & \(0,10\) & \(0,10\) & \(0,10\) & \(0,10\) \\
\hline
\end{tabular}
\caption{Dane dla przykładu \ref{ex:karp1}.}
\label{tab:karp_flat1}
\end{table}

Ponieważ eksperymentalnie wyznaczona część sekwencyjna algorytmu nie rośnie wraz z ilością procesorów, możemy wnioskować, że zbyt duża część obliczeń jest inherentnie sekwencyjna.
\end{przyklad}

\begin{przyklad}\label{ex:karp2}
Powiedzmy, że testując algorytm równoległy na \(1, 2, \dots, 8\) procesorach otrzymaliśmy pewne przyspieszenia w zależności od ilości procesów i z wyrażenia \ref{eq:karp_flatt_3} obliczyliśmy eksperymentalnie wyznaczoną część sekwencyjną f. Dane zebrane są w tablicy \ref{tab:karp_flat2}.

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\(p\) & \(2\) & \(3\) & \(4\) & \(5\) & \(6\) & \(7\) & \(8\) \\
\hline
\(S_p(n)\) & \(1,87\) & \(2,61\) & \(3,23\) & \(3,73\) & \(4,14\) & \(4,46\) & \(w4,71\) \\
\hline
\(f\) & \(0,070\) & \(0,075\) & \(0,080\) & \(0,085\) & \(0,090\) & \(0,095\) & \(0,10\) \\
\hline
\end{tabular}
\caption{Dane dla przykładu \ref{ex:karp2}.}
\label{tab:karp_flat2}
\end{table}
Ponieważ eksperymentalnie wyznaczona część sekwencyjna algorytmu rośnie wraz z ilością procesorów, możemy wnioskować, że przyczyną niskiego przyspieszenia jest organizacja obliczeń równoległych, tj. czas poświęcony uruchomieniu procesów, komunikacji między nimi, synchronizacji lub ograniczenia samej architektury.
\end{przyklad}
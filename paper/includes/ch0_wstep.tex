Golub\cite{Golub} we wstępie do swojej książki poświęconej w całości tylko problemowi działań na macierzach powiada, że mnożenie macierzy, choć jest pomysłem zupełnie prostym, gdy tylko spojrzeć nań z obliczeniowego punktu widzenia, oferuje wielkie bogactwo podejść i przy tym pozostaje dla każdego pierwszym problem, który prowadzi do zajmowania się macierzami w ogóle. 


Problem mnożenia macierzy był podejmowany przez wielu autorów na przestrzeni lat (przykładowo prace \cite{Strassen68}, \cite{Winograd}, \cite{Cannon:1969:CCI:905686} jeszcze z lat '60, ale i całkiem nowa i ważna praca \cite{DBLP:journals/corr/abs-1202-3173}) i pozostaje polem poszukiwań lepszych algorytmów. Podejściem na miarę współczesnych obliczeń komputerowych są obliczenia rozproszone, a w szczególności -- równoległe. Powody takiego stanu rzeczy można określić w trzech punktach:
\begin{enumerate}
\item{Stały spadek kosztów sprzętu komputerowego.}
\item{Rozwój VLSI (\emph{Very-large-scale integration}) do poziomu umożliwiającego projektowanie układów scalonych zawierających miliony tranzystorów na pojedyńczym chipie.}
\item{Osiągnięcie fizycznych ograniczeń czasu cyklu procesora w architekturze von Neumanna.}
\end{enumerate}


Jeśli macierz posiada jakąś określoną wewnętrzną strukturę, na ogół możemy ją wykorzystać. Operacje na macierzach symetrycznych na przykład ze względu na powtarzanie się elementów, czy macierze rzadkie i trójkątne ze względu na wiele elementów zerowych wymagają mniej obliczeń. To przykłady niejednorodności problemu z którym mamy do czyniania. Jest to przyczyna, która w poszukiwaniu metod optymalnych prowadzi do rozwoju metod szczególnych. 


W niniejszej pracy zajmiemy się metodami najogólniejszymi -- metodami dla macierzy gęstych. Szczególna uwaga została położona na metodę Cannona\cite{Cannon:1969:CCI:905686} zaproponowaną w 1969 i rozwiniętą w pracy Ho, Johnnsona i Edelmana\cite{Ching-TienHo1991} z 1991 roku. Przeanalizowana w rozdziale \ref{ch:matrix_multiplication} została klasyczna koncepcja zaproponowana przez Cannona, a w części \ref{app:improvements} omówiono pewne poprawki zmniejszające koszty komunikacji algorytmu. Ponadto przedstawione zostały metody obliczeń w modelu z pamięcią wspólną. W rozdziale \ref{ch:performance} przedstawiono przyspieszenia uzyskane przez implementację hybrydowych wariantów algorytmu Cannona, algorytmu w wersji gruboziarnistej oraz metod wykorzystujących architektury z pamięcią wspólną.
Rozdział \ref{ch:basics} stanowi podbudowę teoretyczną pod koncepcje rozwijane w rozdziałach późniejszych.


% Praca od początku do końca miała charakter przygody, której zawdzięczam pierwsze szlify w programowaniu równoległym.
